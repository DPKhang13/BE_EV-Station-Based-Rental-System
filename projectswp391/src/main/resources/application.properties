# =====================================
# APP CONFIG
# =====================================
spring.config.import=optional:file:.env[.properties],optional:file:.env.${APP_ENV:local}[.properties]
spring.application.name=rental-car
server.port=${PORT:8080}

# ===============================
# DATABASE CONFIG (Neon)
# ===============================
# IMPORTANT: For Neon, use Connection Pooler URL (port 5432) for better performance
# Connection Pooler URL format: jdbc:postgresql://{host}:5432/{database}?sslmode=require
# Neon Connection Pooler supports more connections (up to 100) and better performance
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
spring.datasource.hikari.maximum-pool-size=${DB_POOL_MAX:5}
spring.datasource.hikari.minimum-idle=${DB_POOL_MIN:2}
=======
=======
>>>>>>> carent
# Connection pool settings optimized for Supabase
# If using Connection Pooler (port 6543): can use 5-10 connections
# If using Direct connection (port 5432): must use 1 connection only
spring.datasource.hikari.maximum-pool-size=${DB_POOL_MAX:2}
spring.datasource.hikari.minimum-idle=${DB_POOL_MIN:1}
<<<<<<< HEAD
=======
# Connection pool settings optimized for Neon
# Neon Connection Pooler can handle 5-10 connections safely
# Direct connection (without pooler) should use 1-2 connections only
spring.datasource.hikari.maximum-pool-size=${DB_POOL_MAX:5}
spring.datasource.hikari.minimum-idle=${DB_POOL_MIN:2}
>>>>>>> 42511921db2cf6ea3186d9ad5c681a98adf1061b
=======
>>>>>>> carent
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000
spring.datasource.hikari.leak-detection-threshold=60000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.validation-timeout=3000
spring.datasource.hikari.keepalive-time=300000
<<<<<<< HEAD
# CRITICAL: Disable prepared statements for Neon Connection Pooler
# This fixes "prepared statement already exists" error when using connection pooling
spring.datasource.hikari.data-source-properties.prepareThreshold=0
spring.datasource.hikari.data-source-properties.preparedStatementCacheQueries=0
spring.datasource.hikari.data-source-properties.preparedStatementCacheSizeMiB=0
>>>>>>> db0a89abfffe3fa36bc32a98001a2b0c511a923e
=======
# CRITICAL: Disable prepared statements for Supabase Connection Pooler
# This fixes "prepared statement already exists" error
spring.datasource.hikari.data-source-properties.prepareThreshold=0
spring.datasource.hikari.data-source-properties.preparedStatementCacheQueries=0
spring.datasource.hikari.data-source-properties.preparedStatementCacheSizeMiB=0
>>>>>>> carent

spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO:none}
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=${SPRING_JPA_SHOW_SQL:true}
<<<<<<< HEAD
=======
# Optimize for Neon Connection Pooler - avoid prepared statement conflicts
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
# Use delayed connection acquisition to reduce connection usage
spring.jpa.properties.hibernate.connection.handling_mode=delayed_acquisition_and_release_after_statement
spring.jpa.properties.hibernate.jdbc.time_zone=UTC
# Disable statement caching to avoid conflicts with Neon pooler
spring.jpa.properties.hibernate.jdbc.use_get_generated_keys=true
>>>>>>> 42511921db2cf6ea3186d9ad5c681a98adf1061b


# =====================================
# LONGVAN STORAGE
# =====================================
longvan.s3.endpoint=${LONGVAN_ENDPOINT}
longvan.s3.region=${LONGVAN_REGION}
longvan.s3.bucket=${LONGVAN_BUCKET}
longvan.s3.accessKey=${LONGVAN_ACCESS_KEY}
longvan.s3.secretKey=${LONGVAN_SECRET_KEY}

# =====================================
# MAIL CONFIG
# =====================================
spring.mail.host=${SPRING_MAIL_HOST}
spring.mail.port=${SPRING_MAIL_PORT}
spring.mail.username=${SPRING_MAIL_USERNAME}
spring.mail.password=${SPRING_MAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_AUTH}
spring.mail.properties.mail.smtp.starttls.enable=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_STARTTLS_ENABLE}
spring.mail.properties.mail.smtp.connectiontimeout=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_CONNECTIONTIMEOUT}
spring.mail.properties.mail.smtp.timeout=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_TIMEOUT}
spring.mail.properties.mail.smtp.writetimeout=${SPRING_MAIL_PROPERTIES_MAIL_SMTP_WRITETIMEOUT}

# =====================================
# JWT CONFIG
# =====================================
JWT_ACCESSKEY=${JWT_ACCESSKEY}
JWT_REFRESHKEY=${JWT_REFRESHKEY}
JWT_ACCESSEXPIRATION=${JWT_ACCESSEXPIRATION}
JWT_REFRESHEXPIRATION=${JWT_REFRESHEXPIRATION}

# =====================================
# MOMO PAYMENT CONFIG
# =====================================
momo.partner-code=${MOMO_PARTNER_CODE}
momo.access-key=${MOMO_ACCESS_KEY}
momo.secret-key=${MOMO_SECRET_KEY}
momo.endpoint=${MOMO_ENDPOINT}
momo.return-url=${MOMO_RETURN_URL}
momo.notify-url=${MOMO_NOTIFY_URL}
momo.request-type=${MOMO_REQUEST_TYPE}
